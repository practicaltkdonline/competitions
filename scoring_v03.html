<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>搏擊計分遊戲</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.20.6/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error(e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }
  </script>
</head>
<body class="bg-gray-900 text-white flex min-h-screen overflow-hidden">
  <div id="root" class="flex flex-1"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    function ScoreGame() {
      const [leftScore, setLeftScore] = useState(0);
      const [rightScore, setRightScore] = useState(0);
      const [leftHearts, setLeftHearts] = useState(5);
      const [rightHearts, setRightHearts] = useState(5);
      const [history, setHistory] = useState([]);
      const [leftLog, setLeftLog] = useState([]);
      const [rightLog, setRightLog] = useState([]);
      const [controllerConnected, setControllerConnected] = useState([]);
      const [buttonStates, setButtonStates] = useState({});
      const [buttonPressTimestamps, setButtonPressTimestamps] = useState({});
      const [result, setResult] = useState('');
      const [timerOn, setTimerOn] = useState(false);
      const [isTimerRunning, setIsTimerRunning] = useState(false);
      const [timerSeconds, setTimerSeconds] = useState(120);
      const [timerMilliseconds, setTimerMilliseconds] = useState(0);
      const [matchMode, setMatchMode] = useState(false);
      const [controllerCount, setControllerCount] = useState(1);
      const [controllerPositions, setControllerPositions] = useState(['J1']);
      const [heartTermination, setHeartTermination] = useState(false);
      const [heartTerminationTriggered, setHeartTerminationTriggered] = useState(false);
      const [scoreDiff12, setScoreDiff12] = useState('off');
      const [scoreDiff12Triggered, setScoreDiff12Triggered] = useState(false);
      const [settingsOpen, setSettingsOpen] = useState(false);
      const [overtimeOpen, setOvertimeOpen] = useState(false);
      const [overtimeSeconds, setOvertimeSeconds] = useState(30);
      const [countdownTime, setCountdownTime] = useState(120);
      const [selectedOption, setSelectedOption] = useState(0);
      const [isEditingTime, setIsEditingTime] = useState(false);
      const [isEditingManual, setIsEditingManual] = useState(false);
      const [isEditingPosition, setIsEditingPosition] = useState(false);
      const [isEditingBasicSettings, setIsEditingBasicSettings] = useState(false);
      const [isEditingMatchSettings, setIsEditingMatchSettings] = useState(false);
      const [basicSettingsOption, setBasicSettingsOption] = useState(0);
      const [matchSettingsOption, setMatchSettingsOption] = useState(0);
      const [tempManualMinutes, setTempManualMinutes] = useState(2);
      const [tempManualSeconds, setTempManualSeconds] = useState(0);
      const [editingDigit, setEditingDigit] = useState(0);
      const [editingController, setEditingController] = useState(0);
      const [vibrationOn, setVibrationOn] = useState(false);
      const [helpTextOn, setHelpTextOn] = useState(true);
      const [leftButtonFlash, setLeftButtonFlash] = useState({});
      const [rightButtonFlash, setRightButtonFlash] = useState({});

      useEffect(() => {
        let timerInterval;
        if (timerOn && isTimerRunning) {
          timerInterval = setInterval(() => {
            setTimerMilliseconds(prevMs => {
              if (prevMs <= 0) {
                setTimerSeconds(prevSec => {
                  if (prevSec <= 0) {
                    clearInterval(timerInterval);
                    setIsTimerRunning(false);
                    setTimerMilliseconds(0);
                    setOvertimeOpen(true);
                    return 0;
                  }
                  return prevSec - 1;
                });
                return 990;
              }
              return prevMs - 10;
            });
          }, 10);
        }
        return () => {
          if (timerInterval) clearInterval(timerInterval);
        };
      }, [timerOn, isTimerRunning]);

      useEffect(() => {
        const handleGamepadConnected = (e) => {
          setControllerConnected(prev => {
            const newConnected = [...prev];
            newConnected[e.gamepad.index] = true;
            return newConnected;
          });
          setControllerPositions(prev => {
            const newPositions = [...prev];
            if (!newPositions[e.gamepad.index]) {
              newPositions[e.gamepad.index] = `J${e.gamepad.index + 1}`;
            }
            return newPositions;
          });
          setLeftButtonFlash(prev => ({
            ...prev,
            [e.gamepad.index]: { up: false, L1: false, L2: false, right: false, left: false }
          }));
          setRightButtonFlash(prev => ({
            ...prev,
            [e.gamepad.index]: { circle: false, square: false, R2: false, R1: false, triangle: false }
          }));
        };

        const handleGamepadDisconnected = (e) => {
          setControllerConnected(prev => {
            const newConnected = [...prev];
            newConnected[e.gamepad.index] = false;
            return newConnected;
          });
          setLeftButtonFlash(prev => {
            const newFlash = { ...prev };
            delete newFlash[e.gamepad.index];
            return newFlash;
          });
          setRightButtonFlash(prev => {
            const newFlash = { ...prev };
            delete newFlash[e.gamepad.index];
            return newFlash;
          });
        };

        window.addEventListener('gamepadconnected', handleGamepadConnected);
        window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);

        const countPoints = (log, points) => log.filter(entry => entry.includes(points)).length;

        const determineWinner = () => {
          if (leftScore > rightScore) return '藍方勝';
          if (rightScore > leftScore) return '紅方勝';
          
          const leftPlus5 = countPoints(leftLog, '+5');
          const rightPlus5 = countPoints(rightLog, '+5');
          if (leftPlus5 > rightPlus5) return '藍方勝';
          if (rightPlus5 > leftPlus5) return '紅方勝';

          const leftPlus4 = countPoints(leftLog, '+4');
          const rightPlus4 = countPoints(rightLog, '+4');
          if (leftPlus4 > rightPlus4) return '藍方勝';
          if (rightPlus4 > leftPlus4) return '紅方勝';

          const leftPlus3 = countPoints(leftLog, '+3');
          const rightPlus3 = countPoints(rightLog, '+3');
          if (leftPlus3 > rightPlus3) return '藍方勝';
          if (rightPlus3 > leftPlus3) return '紅方勝';

          const leftPlus2 = countPoints(leftLog, '+2');
          const rightPlus2 = countPoints(rightLog, '+2');
          if (leftPlus2 > rightPlus2) return '藍方勝';
          if (rightPlus2 > leftPlus2) return '紅方勝';

          const leftPlus1 = countPoints(leftLog, '+1');
          const rightPlus1 = countPoints(rightLog, '+1');
          if (leftPlus1 > rightPlus1) return '藍方勝';
          if (rightPlus1 > leftPlus1) return '紅方勝';

          if (leftHearts < rightHearts) return '藍方勝';
          if (rightHearts < leftHearts) return '紅方勝';

          return '平手，請選擇勝方';
        };

        const triggerVibration = (gamepad) => {
          if (vibrationOn && gamepad && gamepad.vibrationActuator) {
            gamepad.vibrationActuator.playEffect('dual-rumble', {
              duration: 200,
              strongMagnitude: 0.5,
              weakMagnitude: 0.5
            });
          }
        };

        const pollGamepads = () => {
          const gamepads = navigator.getGamepads();
          const newButtonStates = {};
          const newButtonPressTimestamps = { ...buttonPressTimestamps };
          let requiredPresses = matchMode ? controllerCount : 1;
          let j1Buttons = { options: false, share: false, touchpad: false, L3: false, R3: false };
          const currentTime = Date.now();

          for (let i = 0; i < gamepads.length; i++) {
            if (!newButtonPressTimestamps[i]) newButtonPressTimestamps[i] = {};
            ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options'].forEach(button => {
              if (!newButtonPressTimestamps[i][button]) newButtonPressTimestamps[i][button] = [];
            });
          }

          for (let i = 0; i < gamepads.length; i++) {
            const gamepad = gamepads[i];
            if (gamepad) {
              const buttons = gamepad.buttons;
              const position = controllerPositions[i] || `J${i + 1}`;
              newButtonStates[i] = {
                L1: buttons[4].pressed,
                L2: buttons[6].pressed,
                R1: buttons[5].pressed,
                R2: buttons[7].pressed,
                up: buttons[12].pressed,
                right: buttons[15].pressed,
                down: buttons[13].pressed,
                left: buttons[14].pressed,
                triangle: buttons[3].pressed,
                square: buttons[2].pressed,
                cross: buttons[0].pressed,
                circle: buttons[1].pressed,
                L3: buttons[10].pressed,
                R3: buttons[11].pressed,
                options: buttons[9].pressed,
                share: buttons[8].pressed,
                touchpad: buttons[17]?.pressed || false,
              };

              if (position === 'J1') {
                j1Buttons = newButtonStates[i];
              }

              if (!settingsOpen && !result && !overtimeOpen) {
                const updateTimestamps = (button) => {
                  if (newButtonStates[i][button] && !buttonStates[i]?.[button]) {
                    newButtonPressTimestamps[i][button].push(currentTime);
                    if (['up', 'L1', 'L2', 'right', 'left'].includes(button)) {
                      setLeftButtonFlash(prev => ({
                        ...prev,
                        [i]: { ...prev[i], [button]: true }
                      }));
                      setTimeout(() => {
                        setLeftButtonFlash(prev => ({
                          ...prev,
                          [i]: { ...prev[i], [button]: false }
                        }));
                      }, 300);
                    }
                    if (['triangle', 'square', 'R2', 'R1', 'circle'].includes(button)) {
                      setRightButtonFlash(prev => ({
                        ...prev,
                        [i]: { ...prev[i], [button]: true }
                      }));
                      setTimeout(() => {
                        setRightButtonFlash(prev => ({
                          ...prev,
                          [i]: { ...prev[i], [button]: false }
                        }));
                      }, 300);
                    }
                  }
                };

                ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options'].forEach(button => {
                  updateTimestamps(button);
                });
              }
            }
          }

          for (let i = 0; i < gamepads.length; i++) {
            if (newButtonPressTimestamps[i]) {
              ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options'].forEach(button => {
                newButtonPressTimestamps[i][button] = newButtonPressTimestamps[i][button].filter(ts => currentTime - ts <= 1000);
              });
            }
          }

          const checkSimultaneousPresses = (button, points, side, setScore, setLog, setHistory, prevScore, prevHearts) => {
            let presses = [];
            for (let i = 0; i < gamepads.length; i++) {
              if (newButtonPressTimestamps[i]?.[button]?.length > 0) {
                newButtonPressTimestamps[i][button].forEach(ts => {
                  if (currentTime - ts <= 1000) {
                    presses.push({ index: i, position: controllerPositions[i] || `J${i + 1}`, timestamp: ts });
                  }
                });
              }
            }

            if (matchMode && controllerCount >= 2) {
              presses.sort((a, b) => a.timestamp - b.timestamp);
              while (presses.length >= requiredPresses) {
                const matchedControllers = [];
                const matchedTimestamps = [];
                let earliestTimestamp = presses[0].timestamp;

                let uniqueControllers = new Set();
                for (let i = 0; i < presses.length && uniqueControllers.size < requiredPresses; i++) {
                  if (Math.abs(presses[i].timestamp - earliestTimestamp) <= 1000 && !uniqueControllers.has(presses[i].index)) {
                    matchedControllers.push(presses[i]);
                    matchedTimestamps.push(presses[i].timestamp);
                    uniqueControllers.add(presses[i].index);
                  }
                }

                if (matchedControllers.length >= requiredPresses) {
                  const positions = matchedControllers.map(p => p.position).sort().join('/');
                  setScore(prev => {
                    setHistory(prevHistory => [...prevHistory, { side, type: 'score', points, prevScore, prevHearts }]);
                    setLog(prevLog => [`${positions}:+${points}`, ...prevLog].slice(0, 10));
                    matchedControllers.forEach(p => triggerVibration(gamepads[p.index]));
                    return prev + points;
                  });

                  matchedControllers.forEach(p => {
                    const idx = newButtonPressTimestamps[p.index][button].indexOf(p.timestamp);
                    if (idx !== -1) {
                      newButtonPressTimestamps[p.index][button].splice(idx, 1);
                    }
                  });
                  presses = presses.filter(p => !matchedTimestamps.includes(p.timestamp));
                } else {
                  break;
                }
              }
            } else {
              presses.forEach(p => {
                setScore(prev => {
                  setHistory(prevHistory => [...prevHistory, { side, type: 'score', points, prevScore, prevHearts }]);
                  setLog(prevLog => [`${p.position}:+${points}`, ...prevLog].slice(0, 10));
                  triggerVibration(gamepads[p.index]);
                  const idx = newButtonPressTimestamps[p.index][button].indexOf(p.timestamp);
                  if (idx !== -1) {
                    newButtonPressTimestamps[p.index][button].splice(idx, 1);
                  }
                  return prev + points;
                });
              });
            }
          };

          if (!result && !settingsOpen && !overtimeOpen) {
            checkSimultaneousPresses('L1', 2, 'left', setLeftScore, setLeftLog, setHistory, leftScore, leftHearts);
            checkSimultaneousPresses('L2', 3, 'left', setLeftScore, setLeftLog, setHistory, leftScore, leftHearts);
            checkSimultaneousPresses('up', 1, 'left', setLeftScore, setLeftLog, setHistory, leftScore, leftHearts);
            checkSimultaneousPresses('right', 4, 'left', setLeftScore, setLeftLog, setHistory, leftScore, leftHearts);
            checkSimultaneousPresses('left', 5, 'left', setLeftScore, setLeftLog, setHistory, leftScore, leftHearts);
            checkSimultaneousPresses('R1', 2, 'right', setRightScore, setRightLog, setHistory, rightScore, rightHearts);
            checkSimultaneousPresses('R2', 3, 'right', setRightScore, setRightLog, setHistory, rightScore, rightHearts);
            checkSimultaneousPresses('triangle', 1, 'right', setRightScore, setRightLog, setHistory, rightScore, rightHearts);
            checkSimultaneousPresses('square', 4, 'right', setRightScore, setRightLog, setHistory, rightScore, rightHearts);
            checkSimultaneousPresses('circle', 5, 'right', setRightScore, setRightLog, setHistory, rightScore, rightHearts);

            if (j1Buttons.down && !buttonStates[0]?.down && controllerPositions[0] === 'J1') {
              setLeftHearts(prev => {
                const newHearts = Math.max(0, prev - 1);
                setHistory(prevHistory => [...prevHistory, { side: 'left', type: 'heart', points: 1, prevScore: rightScore, prevHearts: prev }]);
                setRightScore(prevScore => {
                  setRightLog(prevLog => [`J1:+1`, ...prevLog].slice(0, 10));
                  triggerVibration(gamepads[0]);
                  if (newButtonPressTimestamps[0]) newButtonPressTimestamps[0].down = [];
                  return prevScore + 1;
                });
                return newHearts;
              });
            }
            if (j1Buttons.cross && !buttonStates[0]?.cross && controllerPositions[0] === 'J1') {
              setRightHearts(prev => {
                const newHearts = Math.max(0, prev - 1);
                setHistory(prevHistory => [...prevHistory, { side: 'right', type: 'heart', points: 1, prevScore: leftScore, prevHearts: prev }]);
                setLeftScore(prevScore => {
                  setLeftLog(prevLog => [`J1:+1`, ...prevLog].slice(0, 10));
                  triggerVibration(gamepads[0]);
                  if (newButtonPressTimestamps[0]) newButtonPressTimestamps[0].cross = [];
                  return prevScore + 1;
                });
                return newHearts;
              });
            }

            if (j1Buttons.L3 && !buttonStates[0]?.L3 && !j1Buttons.R3 && controllerPositions[0] === 'J1') {
              const lastLeft = history.filter(h => h.side === 'left').pop();
              if (lastLeft) {
                if (lastLeft.type === 'score') {
                  setLeftScore(lastLeft.prevScore);
                  setLeftLog(prevLog => prevLog.slice(1));
                } else if (lastLeft.type === 'heart') {
                  setLeftHearts(prev => {
                    const newHearts = lastLeft.prevHearts;
                    if (newHearts > 0 && prev === 0) {
                      setHeartTerminationTriggered(false);
                    }
                    return newHearts;
                  });
                  setRightScore(lastLeft.prevScore);
                  setRightLog(prevLog => prevLog.slice(1));
                }
                setHistory(prevHistory => prevHistory.filter(h => h !== lastLeft));
                if (scoreDiff12 === 'on' && Math.abs(lastLeft.prevScore - rightScore) < 12) {
                  setScoreDiff12Triggered(false);
                } else if (scoreDiff12 === 'golden' && lastLeft.prevScore < 2 && rightScore < 2) {
                  setScoreDiff12Triggered(false);
                }
                triggerVibration(gamepads[0]);
              }
            }

            if (j1Buttons.R3 && !buttonStates[0]?.R3 && !j1Buttons.L3 && controllerPositions[0] === 'J1') {
              const lastRight = history.filter(h => h.side === 'right').pop();
              if (lastRight) {
                if (lastRight.type === 'score') {
                  setRightScore(lastRight.prevScore);
                  setRightLog(prevLog => prevLog.slice(1));
                } else if (lastRight.type === 'heart') {
                  setRightHearts(prev => {
                    const newHearts = lastRight.prevHearts;
                    if (newHearts > 0 && prev === 0) {
                      setHeartTerminationTriggered(false);
                    }
                    return newHearts;
                  });
                  setLeftScore(lastRight.prevScore);
                  setLeftLog(prevLog => prevLog.slice(1));
                }
                setHistory(prevHistory => prevHistory.filter(h => h !== lastRight));
                if (scoreDiff12 === 'on' && Math.abs(leftScore - lastRight.prevScore) < 12) {
                  setScoreDiff12Triggered(false);
                } else if (scoreDiff12 === 'golden' && leftScore < 2 && lastRight.prevScore < 2) {
                  setScoreDiff12Triggered(false);
                }
                triggerVibration(gamepads[0]);
              }
            }

            if (j1Buttons.L3 && j1Buttons.R3 && (!buttonStates[0]?.L3 || !buttonStates[0]?.R3) && controllerPositions[0] === 'J1') {
              setLeftScore(0);
              setRightScore(0);
              setLeftHearts(5);
              setRightHearts(5);
              setHistory([]);
              setLeftLog([]);
              setRightLog([]);
              setResult('');
              setTimerSeconds(countdownTime);
              setTimerMilliseconds(0);
              setIsTimerRunning(false);
              setOvertimeOpen(false);
              setHeartTerminationTriggered(false);
              setScoreDiff12Triggered(false);
              setButtonPressTimestamps({});
              triggerVibration(gamepads[0]);
            }

            if (scoreDiff12 === 'on' && !result && !scoreDiff12Triggered && Math.abs(leftScore - rightScore) >= 12) {
              setResult(determineWinner());
              setIsTimerRunning(false);
              setScoreDiff12Triggered(true);
              setHeartTerminationTriggered(true);
            } else if (scoreDiff12 === 'golden' && !result && !scoreDiff12Triggered && (leftScore >= 2 || rightScore >= 2)) {
              setResult(determineWinner());
              setIsTimerRunning(false);
              setScoreDiff12Triggered(true);
              setHeartTerminationTriggered(true);
            }

            if (heartTermination && !result && !heartTerminationTriggered && (leftHearts === 0 || rightHearts === 0)) {
              setResult(determineWinner());
              setIsTimerRunning(false);
              setHeartTerminationTriggered(true);
              setScoreDiff12Triggered(true);
            }

            if (j1Buttons.options && !buttonStates[0]?.options && controllerPositions[0] === 'J1') {
              setSettingsOpen(true);
              setIsTimerRunning(false);
              if (newButtonPressTimestamps[0]) newButtonPressTimestamps[0].options = [];
              triggerVibration(gamepads[0]);
            }
          }

          if ((settingsOpen && !prevSettingsOpen) || (result && !prevResult) || (overtimeOpen && !prevOvertimeOpen)) {
            for (let i = 0; i < gamepads.length; i++) {
              if (newButtonPressTimestamps[i]) {
                ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options'].forEach(button => {
                  newButtonPressTimestamps[i][button] = [];
                });
              }
            }
          }

          if (!settingsOpen && !result && !overtimeOpen) {
            if (j1Buttons.share && !buttonStates[0]?.share) {
              setResult(determineWinner());
              setIsTimerRunning(false);
              setHeartTerminationTriggered(true);
              setScoreDiff12Triggered(true);
            }

            if (j1Buttons.touchpad && !buttonStates[0]?.touchpad && timerOn) {
              setIsTimerRunning(prev => {
                if (!prev && timerSeconds === 0 && timerMilliseconds === 0) {
                  setTimerSeconds(countdownTime);
                  setTimerMilliseconds(0);
                }
                return !prev;
              });
            }
          }

          if (!overtimeOpen && j1Buttons.cross && !buttonStates[0]?.cross && result) {
            setResult('');
            if (scoreDiff12 === 'on' && Math.abs(leftScore - rightScore) < 12) {
              setScoreDiff12Triggered(false);
            } else if (scoreDiff12 === 'golden' && leftScore < 2 && rightScore < 2) {
              setScoreDiff12Triggered(false);
            }
          } else if (result === '平手，請選擇勝方') {
            if (j1Buttons.left && !buttonStates[0]?.left) {
              setResult('藍方勝');
            }
            if (j1Buttons.right && !buttonStates[0]?.right) {
              setResult('紅方勝');
            }
          }

          if (overtimeOpen && controllerPositions[0] === 'J1') {
            if (j1Buttons.triangle && !buttonStates[0]?.triangle) {
              setResult(determineWinner());
              setOvertimeOpen(false);
              setHeartTerminationTriggered(true);
              setScoreDiff12Triggered(true);
            }
            if (j1Buttons.circle && !buttonStates[0]?.circle) {
              setTimerSeconds(overtimeSeconds);
              setTimerMilliseconds(0);
              setOvertimeOpen(false);
              setIsTimerRunning(false);
            }
            if (j1Buttons.cross && !buttonStates[0]?.cross) {
              setOvertimeOpen(false);
            }
            if (j1Buttons.left && !buttonStates[0]?.left) {
              setOvertimeSeconds(prev => Math.max(5, prev - 5));
            }
            if (j1Buttons.right && !buttonStates[0]?.right) {
              setOvertimeSeconds(prev => Math.min(60, prev + 5));
            }
          }

          if (settingsOpen && controllerPositions[0] === 'J1') {
            const matchSettingsMaxOption = timerOn ? (matchMode ? 5 : 4) : (matchMode ? 4 : 3);
            const basicSettingsMaxOption = 2;
            if (!isEditingTime && !isEditingManual && !isEditingPosition && !isEditingBasicSettings && !isEditingMatchSettings) {
              if (j1Buttons.up && !buttonStates[0]?.up) {
                setSelectedOption(prev => (prev === 0 ? 1 : 0));
              }
              if (j1Buttons.down && !buttonStates[0]?.down) {
                setSelectedOption(prev => (prev === 1 ? 0 : 1));
              }
              if (j1Buttons.circle && !buttonStates[0]?.circle) {
                if (selectedOption === 0) {
                  setIsEditingMatchSettings(true);
                  setMatchSettingsOption(0);
                } else if (selectedOption === 1) {
                  setIsEditingBasicSettings(true);
                  setBasicSettingsOption(0);
                }
              }
              if (j1Buttons.cross && !buttonStates[0]?.cross) {
                setSettingsOpen(false);
                setSelectedOption(0);
              }
            } else if (isEditingMatchSettings && !isEditingTime && !isEditingManual && !isEditingPosition) {
              if (j1Buttons.up && !buttonStates[0]?.up) {
                setMatchSettingsOption(prev => (prev === 0 ? matchSettingsMaxOption : prev - 1));
              }
              if (j1Buttons.down && !buttonStates[0]?.down) {
                setMatchSettingsOption(prev => (prev === matchSettingsMaxOption ? 0 : prev + 1));
              }
              if (j1Buttons.circle && !buttonStates[0]?.circle) {
                if (timerOn && matchSettingsOption === 1) {
                  setIsEditingManual(true);
                  setTempManualMinutes(Math.floor(countdownTime / 60));
                  setTempManualSeconds(countdownTime % 60);
                  setEditingDigit(0);
                }
              }
              if (j1Buttons.left && !buttonStates[0]?.left) {
                if (matchSettingsOption === 0) {
                  setTimerOn(prev => {
                    const newTimerOn = !prev;
                    if (!newTimerOn) {
                      setIsTimerRunning(false);
                      setTimerSeconds(countdownTime);
                      setTimerMilliseconds(0);
                    }
                    return newTimerOn;
                  });
                } else if (timerOn && matchSettingsOption === 1) {
                  setCountdownTime(prev => {
                    const newTime = Math.min(5999, prev + 15);
                    setTimerSeconds(newTime);
                    setTimerMilliseconds(0);
                    setIsTimerRunning(false);
                    return newTime;
                  });
                } else if (matchSettingsOption === (timerOn ? 2 : 1)) {
                  setHeartTermination(prev => !prev);
                } else if (matchSettingsOption === (timerOn ? 3 : 2)) {
                  setScoreDiff12(prev => {
                    const options = ['off', 'on', 'golden'];
                    const currentIndex = options.indexOf(prev);
                    return options[(currentIndex + 2) % 3];
                  });
                } else if (matchSettingsOption === (timerOn ? 4 : 3)) {
                  setMatchMode(prev => !prev);
                } else if (matchMode && matchSettingsOption === (timerOn ? 5 : 4)) {
                  setControllerCount(prev => Math.max(1, prev - 1));
                }
              }
              if (j1Buttons.right && !buttonStates[0]?.right) {
                if (matchSettingsOption === 0) {
                  setTimerOn(prev => {
                    const newTimerOn = !prev;
                    if (!newTimerOn) {
                      setIsTimerRunning(false);
                      setTimerSeconds(countdownTime);
                      setTimerMilliseconds(0);
                    }
                    return newTimerOn;
                  });
                } else if (timerOn && matchSettingsOption === 1) {
                  setCountdownTime(prev => {
                    const newTime = Math.max(0, prev - 15);
                    setTimerSeconds(newTime);
                    setTimerMilliseconds(0);
                    setIsTimerRunning(false);
                    return newTime;
                  });
                } else if (matchSettingsOption === (timerOn ? 2 : 1)) {
                  setHeartTermination(prev => !prev);
                } else if (matchSettingsOption === (timerOn ? 3 : 2)) {
                  setScoreDiff12(prev => {
                    const options = ['off', 'on', 'golden'];
                    const currentIndex = options.indexOf(prev);
                    return options[(currentIndex + 1) % 3];
                  });
                } else if (matchSettingsOption === (timerOn ? 4 : 3)) {
                  setMatchMode(prev => !prev);
                } else if (matchMode && matchSettingsOption === (timerOn ? 5 : 4)) {
                  setControllerCount(prev => Math.min(5, prev + 1));
                }
              }
              if (j1Buttons.cross && !buttonStates[0]?.cross) {
                setIsEditingMatchSettings(false);
                setMatchSettingsOption(0);
              }
            } else if (isEditingManual) {
              if (j1Buttons.left && !buttonStates[0]?.left) {
                setEditingDigit(prev => Math.max(0, prev - 1));
              }
              if (j1Buttons.right && !buttonStates[0]?.right) {
                setEditingDigit(prev => Math.min(3, prev + 1));
              }
              if (j1Buttons.up && !buttonStates[0]?.up) {
                if (editingDigit === 0) {
                  setTempManualMinutes(prev => {
                    const tens = (Math.floor(prev / 10) + 1) % 10;
                    const ones = prev % 10;
                    return Math.min(99, tens * 10 + ones);
                  });
                } else if (editingDigit === 1) {
                  setTempManualMinutes(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 1) % 10;
                    return Math.min(99, tens * 10 + ones);
                  });
                } else if (editingDigit === 2) {
                  setTempManualSeconds(prev => {
                    const tens = (Math.floor(prev / 10) + 1) % 6;
                    const ones = prev % 10;
                    return Math.min(59, tens * 10 + ones);
                  });
                } else if (editingDigit === 3) {
                  setTempManualSeconds(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 1) % 10;
                    return Math.min(59, tens * 10 + ones);
                  });
                }
              }
              if (j1Buttons.down && !buttonStates[0]?.down) {
                if (editingDigit === 0) {
                  setTempManualMinutes(prev => {
                    const tens = (Math.floor(prev / 10) + 9) % 10;
                    const ones = prev % 10;
                    return tens * 10 + ones;
                  });
                } else if (editingDigit === 1) {
                  setTempManualMinutes(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 9) % 10;
                    return tens * 10 + ones;
                  });
                } else if (editingDigit === 2) {
                  setTempManualSeconds(prev => {
                    const tens = (Math.floor(prev / 10) + 5) % 6;
                    const ones = prev % 10;
                    return tens * 10 + ones;
                  });
                } else if (editingDigit === 3) {
                  setTempManualSeconds(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 9) % 10;
                    return tens * 10 + ones;
                  });
                }
              }
              if (j1Buttons.circle && !buttonStates[0]?.circle) {
                const newTime = tempManualMinutes * 60 + tempManualSeconds;
                setCountdownTime(newTime);
                setTimerSeconds(newTime);
                setTimerMilliseconds(0);
                setIsEditingManual(false);
                setIsEditingTime(false);
              }
              if (j1Buttons.cross && !buttonStates[0]?.cross) {
                setIsEditingManual(false);
                setEditingDigit(0);
                setIsEditingTime(false);
              }
            } else if (isEditingPosition) {
              if (j1Buttons.up && !buttonStates[0]?.up) {
                setEditingController(prev => (prev === 0 ? controllerCount - 1 : prev - 1));
              }
              if (j1Buttons.down && !buttonStates[0]?.down) {
                setEditingController(prev => (prev === controllerCount - 1 ? 0 : prev + 1));
              }
              if (j1Buttons.left && !buttonStates[0]?.left) {
                setControllerPositions(prev => {
                  const newPositions = [...prev];
                  const current = parseInt(newPositions[editingController]?.slice(1) || editingController + 1);
                  const next = current === 1 ? 5 : current - 1;
                  newPositions[editingController] = `J${next}`;
                  return newPositions;
                });
              }
              if (j1Buttons.right && !buttonStates[0]?.right) {
                setControllerPositions(prev => {
                  const newPositions = [...prev];
                  const current = parseInt(newPositions[editingController]?.slice(1) || editingController + 1);
                  const next = current === 5 ? 1 : current + 1;
                  newPositions[editingController] = `J${next}`;
                  return newPositions;
                });
              }
              if (j1Buttons.circle && !buttonStates[0]?.circle) {
                setIsEditingPosition(false);
                setEditingController(0);
              }
              if (j1Buttons.cross && !buttonStates[0]?.cross) {
                setIsEditingPosition(false);
                setEditingController(0);
              }
            } else if (isEditingBasicSettings) {
              if (j1Buttons.up && !buttonStates[0]?.up) {
                setBasicSettingsOption(prev => (prev === 0 ? basicSettingsMaxOption : prev - 1));
              }
              if (j1Buttons.down && !buttonStates[0]?.down) {
                setBasicSettingsOption(prev => (prev === basicSettingsMaxOption ? 0 : prev + 1));
              }
              if (j1Buttons.left && !buttonStates[0]?.left) {
                if (basicSettingsOption === 0) {
                  setVibrationOn(prev => !prev);
                } else if (basicSettingsOption === 1) {
                  setHelpTextOn(prev => !prev);
                }
              }
              if (j1Buttons.right && !buttonStates[0]?.right) {
                if (basicSettingsOption === 0) {
                  setVibrationOn(prev => !prev);
                } else if (basicSettingsOption === 1) {
                  setHelpTextOn(prev => !prev);
                }
              }
              if (j1Buttons.circle && !buttonStates[0]?.circle) {
                if (basicSettingsOption === 2) {
                  setIsEditingPosition(true);
                  setEditingController(0);
                }
              }
              if (j1Buttons.cross && !buttonStates[0]?.cross) {
                setIsEditingBasicSettings(false);
                setBasicSettingsOption(0);
              }
            }
          }

          prevSettingsOpen = settingsOpen;
          prevResult = result;
          prevOvertimeOpen = overtimeOpen;

          setButtonStates(newButtonStates);
          setButtonPressTimestamps(newButtonPressTimestamps);
        };

        let prevSettingsOpen = settingsOpen;
        let prevResult = result;
        let prevOvertimeOpen = overtimeOpen;

        const interval = setInterval(pollGamepads, 50);
        return () => {
          clearInterval(interval);
          window.removeEventListener('gamepadconnected', handleGamepadConnected);
          window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
        };
      }, [history, buttonStates, buttonPressTimestamps, settingsOpen, overtimeOpen, result, countdownTime, selectedOption, isEditingTime, isEditingManual, isEditingPosition, isEditingBasicSettings, isEditingMatchSettings, matchSettingsOption, basicSettingsOption, heartTermination, heartTerminationTriggered, vibrationOn, helpTextOn, matchMode, controllerCount, controllerPositions, scoreDiff12, scoreDiff12Triggered, leftScore, rightScore, leftHearts, rightHearts]);

      const formatTimer = (seconds, milliseconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        const ms = Math.floor(milliseconds / 10);
        return (
          <span>
            <span class="text-[4rem]">{`${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`}</span>
            <span class="text-base">{`:${ms.toString().padStart(2, '0')}`}</span>
          </span>
        );
      };

      const formatCountdownTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      };

      const getDigits = () => {
        const minutesTens = Math.floor(tempManualMinutes / 10);
        const minutesOnes = tempManualMinutes % 10;
        const secondsTens = Math.floor(tempManualSeconds / 10);
        const secondsOnes = tempManualSeconds % 10;
        return [minutesTens, minutesOnes, secondsTens, secondsOnes];
      };

      return (
        <div class="flex flex-1 min-h-screen relative">
          {helpTextOn ? (
            <div class="absolute left-4 top-4 text-sm flex flex-col space-y-1 min-h-[100px] min-w-[150px]">
              <p class={timerOn ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                計時: {timerOn ? "開" : "關"}
              </p>
              <p class={heartTermination ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                心型終止: {heartTermination ? "開" : "關"}
              </p>
              <p class={scoreDiff12 !== 'off' ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                分差模式: {scoreDiff12 === 'off' ? '關' : scoreDiff12 === 'on' ? '12分差' : '黃金得分'}
              </p>
              <p class={matchMode ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                比賽模式: {matchMode ? "開" : "關"}
              </p>
              {matchMode && (
                <p class="text-white bg-gray-800 px-2 py-1 rounded">
                  同時按分: {controllerCount}
                </p>
              )}
            </div>
          ) : (
            <div class="absolute left-4 top-4 min-h-[100px] min-w-[150px]"></div>
          )}
          <div class="absolute left-4 top-1/4 text-sm flex flex-col items-start max-w-[150px] min-h-[100px]">
            <p>得分記錄:</p>
            {leftLog.length > 0 && (
              <ul>
                {leftLog.map((entry, index) => (
                  <li key={index}>{entry}</li>
                ))}
              </ul>
            )}
          </div>
          <div class="absolute left-4 bottom-[84px] text-sm flex flex-col items-end max-w-[150px]">
            {controllerConnected.map((connected, i) => connected && (
              <div key={i} class="flex items-end space-x-1 w-[120px]">
                <span class="w-8 text-right">{controllerPositions[i] || `J${i + 1}`}</span>
                <span class="flex space-x-1">
                  {['up', 'L1', 'L2', 'right', 'left'].map(button => (
                    <span key={button} class={leftButtonFlash[i]?.[button] ? "bg-green-400 w-4 h-4 animate-pulse" : "bg-gray-800 w-4 h-4"}></span>
                  ))}
                </span>
              </div>
            ))}
          </div>
          <div class="flex-1 bg-blue-600 flex flex-col items-center justify-center space-y-6">
            <h2 class="text-2xl">藍方分數</h2>
            <p class="text-[24rem] font-bold">{leftScore}</p>
            <p class="text-xl flex space-x-4 bg-black p-2 rounded min-h-[40px]">{Array(leftHearts).fill('❤️').join('')}</p>
            {helpTextOn ? (
              <p class="text-sm min-h-[20px]">L1: +2, L2: +3, 上: +1, 右: +4, 左: +5, J1下: 藍心-1紅分+1, J1 L3: 復原</p>
            ) : (
              <p class="min-h-[20px]"></p>
            )}
          </div>
          <div class="flex-1 bg-red-600 flex flex-col items-center justify-center space-y-6">
            <h2 class="text-2xl">紅方分數</h2>
            <p class="text-[24rem] font-bold">{rightScore}</p>
            <p class="text-xl flex space-x-4 bg-black p-2 rounded min-h-[40px]">{Array(rightHearts).fill('❤️').join('')}</p>
            {helpTextOn ? (
              <p class="text-sm min-h-[20px]">R1: +2, R2: +3, 三角: +1, 方: +4, 圓圈: +5, J1交叉: 紅心-1藍分+1, J1 R3: 復原</p>
            ) : (
              <p class="min-h-[20px]"></p>
            )}
          </div>
          <div class="absolute right-4 top-1/4 text-sm flex flex-col items-start max-w-[150px] min-h-[100px]">
            <p>得分記錄:</p>
            {rightLog.length > 0 && (
              <ul>
                {rightLog.map((entry, index) => (
                  <li key={index}>{entry}</li>
                ))}
              </ul>
            )}
          </div>
          <div class="absolute right-4 bottom-[84px] text-sm flex flex-col items-end max-w-[150px]">
            {controllerConnected.map((connected, i) => connected && (
              <div key={i} class="flex items-end space-x-1 flex-row-reverse space-x-reverse w-[120px] justify-end">
                <span class="w-8 text-left">{controllerPositions[i] || `J${i + 1}`}</span>
                <span class="flex space-x-1">
                  {['circle', 'square', 'R2', 'R1', 'triangle'].map(button => (
                    <span key={button} class={rightButtonFlash[i]?.[button] ? "bg-green-400 w-4 h-4 animate-pulse" : "bg-gray-800 w-4 h-4"}></span>
                  ))}
                </span>
              </div>
            ))}
          </div>
          <div class="absolute top-4 flex flex-col items-center w-full">
            <h1 class="text-3xl font-bold">搏擊計分遊戲</h1>
            {timerOn && (
              <p>{formatTimer(timerSeconds, timerMilliseconds)}</p>
            )}
          </div>
          <div class="absolute bottom-1/4 left-1/2 transform -translate-x-1/2 flex flex-col items-center space-y-2">
            {helpTextOn && (
              <p class="text-lg bg-gray-800 px-4 py-2 rounded min-h-[40px]">J1 Share: 分勝負</p>
            )}
          </div>
          <div class="absolute bottom-10 flex flex-col items-center w-full space-y-2 min-h-[40px]">
            {helpTextOn && (
              <p class="text-sm">J1 L3+R3: 重置, J1 Options: 設定, J1 Touch Pad: 倒數啟動/暫停</p>
            )}
            <p class={controllerConnected.some(c => c) ? "text-green-400" : "text-red-400"}>
              {controllerConnected.some(c => c) ? `手柄已連接: ${controllerPositions.filter((_, i) => controllerConnected[i]).join(', ')}` : "請連接PS4手柄"}
            </p>
          </div>
          {result && (
            <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center space-y-4 w-1/3 z-10">
              {result === '平手，請選擇勝方' ? (
                <div class="flex flex-col items-center space-y-2">
                  <p class="text-[2rem] font-bold">平手</p>
                  <p class="text-[2rem] font-bold">請選擇勝方</p>
                </div>
              ) : (
                <p class="text-[8rem] font-bold">{result}</p>
              )}
              {result === '平手，請選擇勝方' ? (
                <div class="flex flex-col items-center space-y-2">
                  <div class="flex space-x-4">
                    <p class="text-lg bg-blue-600 px-3 py-1 rounded">J1 左: 藍</p>
                    <p class="text-lg bg-red-600 px-3 py-1 rounded">J1 右: 紅</p>
                  </div>
                  <p class="text-base">J1 按交叉關閉</p>
                </div>
              ) : (
                <p class="text-base">J1 按交叉關閉</p>
              )}
            </div>
          )}
          {settingsOpen && (
            <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center space-y-4 w-1/3 z-10">
              <p class="text-2xl font-bold">設定</p>
              {!isEditingMatchSettings && !isEditingTime && !isEditingManual && !isEditingPosition && !isEditingBasicSettings ? (
                <div class="flex flex-col items-center space-y-2 w-full">
                  <p class={selectedOption === 0 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    比賽設置
                  </p>
                  <p class={selectedOption === 1 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    基本設置
                  </p>
                  <p class="text-base">J1 上/下: 選擇, J1 圓圈: 進入, J1 交叉: 關閉</p>
                </div>
              ) : isEditingMatchSettings && !isEditingTime && !isEditingManual && !isEditingPosition ? (
                <div class="flex flex-col items-center space-y-2 w-full">
                  <p class={matchSettingsOption === 0 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    計時: {timerOn ? "開" : "關"}
                  </p>
                  {timerOn && (
                    <p class={matchSettingsOption === 1 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                      倒數時間: {formatCountdownTime(countdownTime)}
                    </p>
                  )}
                  <p class={matchSettingsOption === (timerOn ? 2 : 1) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    心型終止: {heartTermination ? "開" : "關"}
                  </p>
                  <p class={matchSettingsOption === (timerOn ? 3 : 2) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    分差模式: {scoreDiff12 === 'off' ? '關' : scoreDiff12 === 'on' ? '12分差' : '黃金得分'}
                  </p>
                  <p class={matchSettingsOption === (timerOn ? 4 : 3) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    比賽模式: {matchMode ? "開" : "關"}
                  </p>
                  {matchMode && (
                    <p class={matchSettingsOption === (timerOn ? 5 : 4) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                      同時按分: {controllerCount}
                    </p>
                  )}
                  <p class="text-base">J1 上/下: 選擇, J1 左/右: 切換開關/時間/分差模式/同時按分, J1 圓圈: 手動輸入時間, J1 交叉: 返回</p>
                </div>
              ) : isEditingManual ? (
                <div class="flex flex-col items-center space-y-2 w-full">
                  <div class="flex space-x-1">
                    <span class={editingDigit === 0 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {Math.floor(tempManualMinutes / 10)}
                    </span>
                    <span class={editingDigit === 1 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {tempManualMinutes % 10}
                    </span>
                    <span>:</span>
                    <span class={editingDigit === 2 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {Math.floor(tempManualSeconds / 10)}
                    </span>
                    <span class={editingDigit === 3 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {tempManualSeconds % 10}
                    </span>
                  </div>
                  <p class="text-base">J1 左/右: 選擇數字, J1 上/下: 加減, J1 圓圈: 確認, J1 交叉: 返回</p>
                </div>
              ) : isEditingPosition ? (
                <div class="flex flex-col items-center space-y-2 w-full">
                  {Array.from({ length: controllerCount }, (_, i) => (
                    <p key={i} class={editingController === i ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                      控制器 {i + 1}: {controllerPositions[i] || `J${i + 1}`}
                    </p>
                  ))}
                  <p class="text-base">J1 上/下: 選擇控制器, J1 左/右: 更改位置, J1 圓圈: 確認, J1 交叉: 返回</p>
                </div>
              ) : isEditingBasicSettings ? (
                <div class="flex flex-col items-center space-y-2 w-full">
                  <p class={basicSettingsOption === 0 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    振動: {vibrationOn ? "開" : "關"}
                  </p>
                  <p class={basicSettingsOption === 1 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    說明: {helpTextOn ? "開" : "關"}
                  </p>
                  <p class={basicSettingsOption === 2 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    手制位置
                  </p>
                  <p class="text-base">J1 上/下: 選擇, J1 左/右: 切換開關, J1 圓圈: 編輯, J1 交叉: 返回</p>
                </div>
              ) : null}
            </div>
          )}
          {overtimeOpen && (
            <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center space-y-4 w-1/3 z-10">
              <p class="text-2xl font-bold">時間到</p>
              <div class="flex flex-col items-center space-y-2">
                <p class="text-base">J1 分勝負 (按三角)</p>
                <p class="text-base">加時: {overtimeSeconds}秒 (J1 左/右調整, J1 圓圈確認)</p>
                <p class="text-base">J1 取消 (按交叉)</p>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<ScoreGame />, document.getElementById('root'));
  </script>
</body>
</html>