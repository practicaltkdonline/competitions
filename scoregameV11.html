<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>搏擊計分遊戲</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.20.6/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error(e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }
  </script>
</head>
<body class="bg-gray-900 text-white flex min-h-screen overflow-hidden">
  <div id="root" class="flex flex-1"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    function ScoreGame() {
      const [leftScore, setLeftScore] = useState(0);
      const [rightScore, setRightScore] = useState(0);
      const [leftHearts, setLeftHearts] = useState(5);
      const [rightHearts, setRightHearts] = useState(5);
      const [leftHistory, setLeftHistory] = useState([]);
      const [rightHistory, setRightHistory] = useState([]);
      const [leftLog, setLeftLog] = useState([]);
      const [rightLog, setRightLog] = useState([]);
      const [controllerConnected, setControllerConnected] = useState([]);
      const [buttonStates, setButtonStates] = useState({});
      const [buttonPressTimestamps, setButtonPressTimestamps] = useState({});
      const [result, setResult] = useState('');
      const [timerOn, setTimerOn] = useState(false);
      const [isTimerRunning, setIsTimerRunning] = useState(false);
      const [timerSeconds, setTimerSeconds] = useState(120);
      const [timerMilliseconds, setTimerMilliseconds] = useState(0);
      const [matchMode, setMatchMode] = useState(false);
      const [controllerCount, setControllerCount] = useState(1);
      const [controllerPositions, setControllerPositions] = useState([]);
      const [tempControllerPositions, setTempControllerPositions] = useState([]);
      const [controllerIndexMap, setControllerIndexMap] = useState({});
      const [disconnectedTimestamps, setDisconnectedTimestamps] = useState({});
      const [heartTermination, setHeartTermination] = useState(false);
      const [heartTerminationTriggered, setHeartTerminationTriggered] = useState(false);
      const [scoreDiff12, setScoreDiff12] = useState('off');
      const [scoreDiff12Triggered, setScoreDiff12Triggered] = useState(false);
      const [settingsOpen, setSettingsOpen] = useState(false);
      const [overtimeOpen, setOvertimeOpen] = useState(false);
      const [overtimeSeconds, setOvertimeSeconds] = useState(30);
      const [countdownTime, setCountdownTime] = useState(120);
      const [selectedOption, setSelectedOption] = useState(0);
      const [isEditingTime, setIsEditingTime] = useState(false);
      const [isEditingManual, setIsEditingManual] = useState(false);
      const [isEditingPosition, setIsEditingPosition] = useState(false);
      const [isEditingBasicSettings, setIsEditingBasicSettings] = useState(false);
      const [isEditingMatchSettings, setIsEditingMatchSettings] = useState(false);
      const [isEditingManualPosition, setIsEditingManualPosition] = useState(false);
      const [basicSettingsOption, setBasicSettingsOption] = useState(0);
      const [matchSettingsOption, setMatchSettingsOption] = useState(0);
      const [tempManualMinutes, setTempManualMinutes] = useState(2);
      const [tempManualSeconds, setTempManualSeconds] = useState(0);
      const [editingDigit, setEditingDigit] = useState(0);
      const [editingController, setEditingController] = useState(0);
      const [vibrationOn, setVibrationOn] = useState(false);
      const [helpTextOn, setHelpTextOn] = useState(true);
      const [leftButtonFlash, setLeftButtonFlash] = useState({});
      const [rightButtonFlash, setRightButtonFlash] = useState({});
      const [manualPositionOrder, setManualPositionOrder] = useState([]);
      const [tempManualPositions, setTempManualPositions] = useState([]);
      const [bypassMatchMode, setBypassMatchMode] = useState(false);

      useEffect(() => {
        let timerInterval;
        if (timerOn && isTimerRunning) {
          timerInterval = setInterval(() => {
            setTimerMilliseconds(prevMs => {
              if (prevMs <= 0) {
                setTimerSeconds(prevSec => {
                  if (prevSec <= 0) {
                    clearInterval(timerInterval);
                    setIsTimerRunning(false);
                    setTimerMilliseconds(0);
                    setOvertimeOpen(true);
                    return 0;
                  }
                  return prevSec - 1;
                });
                return 990;
              }
              return prevMs - 10;
            });
          }, 10);
        }
        return () => {
          if (timerInterval) clearInterval(timerInterval);
        };
      }, [timerOn, isTimerRunning]);

      useEffect(() => {
        const handleGamepadConnected = (e) => {
          setControllerConnected(prev => {
            const newConnected = [...prev];
            newConnected[e.gamepad.index] = true;
            return newConnected;
          });
          setControllerPositions(prev => {
            const newPositions = [...prev];
            const connectedCount = controllerConnected.filter(c => c).length + 1;
            if (!newPositions[e.gamepad.index]) {
              setControllerIndexMap(prevMap => {
                const newMap = { ...prevMap };
                if (!newMap[e.gamepad.index]) {
                  let newPosition;
                  const j1Exists = Object.values(newMap).includes('J1') || prev.some(p => p === 'J1');
                  const j1Index = Object.keys(newMap).find(key => newMap[key] === 'J1');
                  const currentTime = Date.now();
                  const isJ1LongDisconnected = j1Index && disconnectedTimestamps[j1Index] && (currentTime - disconnectedTimestamps[j1Index] >= 10000);
                  if (!j1Exists || isJ1LongDisconnected) {
                    newPosition = 'J1';
                  } else {
                    newPosition = `J${connectedCount}`;
                  }
                  newMap[e.gamepad.index] = newPosition;
                  if (isJ1LongDisconnected) {
                    delete newMap[j1Index];
                    setDisconnectedTimestamps(prev => {
                      const newTimestamps = { ...prev };
                      delete newTimestamps[j1Index];
                      return newTimestamps;
                    });
                  }
                }
                return newMap;
              });
              newPositions[e.gamepad.index] = controllerIndexMap[e.gamepad.index] || `J${connectedCount}`;
            }
            return newPositions;
          });
          setTempControllerPositions(prev => {
            const connectedCount = controllerConnected.filter(c => c).length + 1;
            const newPositions = new Array(connectedCount).fill('未指派');
            for (let i = 0; i < connectedCount; i++) {
              if (controllerPositions[i]) {
                newPositions[i] = controllerPositions[i];
              }
            }
            return newPositions;
          });
          setTempManualPositions(prev => {
            const connectedCount = controllerConnected.filter(c => c).length + 1;
            return new Array(connectedCount).fill('未輸入');
          });
          setLeftButtonFlash(prev => ({
            ...prev,
            [e.gamepad.index]: { up: false, L1: false, L2: false, right: false, left: false }
          }));
          setRightButtonFlash(prev => ({
            ...prev,
            [e.gamepad.index]: { circle: false, square: false, R2: false, R1: false, triangle: false }
          }));
        };

        const handleGamepadDisconnected = (e) => {
          setControllerConnected(prev => {
            const newConnected = [...prev];
            newConnected[e.gamepad.index] = false;
            return newConnected;
          });
          setDisconnectedTimestamps(prev => ({
            ...prev,
            [e.gamepad.index]: Date.now()
          }));
          setTempControllerPositions(prev => {
            const connectedCount = controllerConnected.filter(c => c).length - 1;
            return new Array(Math.max(0, connectedCount)).fill('未指派');
          });
          setTempManualPositions(prev => {
            const connectedCount = controllerConnected.filter(c => c).length - 1;
            return new Array(Math.max(0, connectedCount)).fill('未輸入');
          });
          setLeftButtonFlash(prev => {
            const newFlash = { ...prev };
            delete newFlash[e.gamepad.index];
            return newFlash;
          });
          setRightButtonFlash(prev => {
            const newFlash = { ...prev };
            delete newFlash[e.gamepad.index];
            return newFlash;
          });
        };

        window.addEventListener('gamepadconnected', handleGamepadConnected);
        window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);

        const countPoints = (log, points) => log.filter(entry => entry.includes(points)).length;

        const determineWinner = () => {
          // 如果藍方心型為 0，紅方勝
          if (leftHearts === 0 && heartTermination) return '紅方勝';
          // 如果紅方心型為 0，藍方勝
          if (rightHearts === 0 && heartTermination) return '藍方勝';
          // 其他情況：比較分數
          if (leftScore > rightScore) return '藍方勝';
          if (rightScore > leftScore) return '紅方勝';
          
          const leftPlus5 = countPoints(leftLog, '+5');
          const rightPlus5 = countPoints(rightLog, '+5');
          if (leftPlus5 > rightPlus5) return '藍方勝';
          if (rightPlus5 > leftPlus5) return '紅方勝';

          const leftPlus4 = countPoints(leftLog, '+4');
          const rightPlus4 = countPoints(rightLog, '+4');
          if (leftPlus4 > rightPlus4) return '藍方勝';
          if (rightPlus4 > leftPlus4) return '紅方勝';

          const leftPlus3 = countPoints(leftLog, '+3');
          const rightPlus3 = countPoints(rightLog, '+3');
          if (leftPlus3 > rightPlus3) return '藍方勝';
          if (rightPlus3 > leftPlus3) return '紅方勝';

          const leftPlus2 = countPoints(leftLog, '+2');
          const rightPlus2 = countPoints(rightLog, '+2');
          if (leftPlus2 > rightPlus2) return '藍方勝';
          if (rightPlus2 > leftPlus2) return '紅方勝';

          const leftPlus1 = countPoints(leftLog, '+1');
          const rightPlus1 = countPoints(rightLog, '+1');
          if (leftPlus1 > rightPlus1) return '藍方勝';
          if (rightPlus1 > leftPlus1) return '紅方勝';

          return '平手，請選擇勝方';
        };

        const triggerVibration = (gamepad) => {
          if (vibrationOn && gamepad && gamepad.vibrationActuator) {
            gamepad.vibrationActuator.playEffect('dual-rumble', {
              duration: 200,
              strongMagnitude: 0.5,
              weakMagnitude: 0.5
            });
          }
        };

        const resetControllerPositions = () => {
          setControllerPositions([]);
          setControllerIndexMap({});
          setDisconnectedTimestamps({});
          setTempControllerPositions([]);
          setTempManualPositions([]);
          setButtonPressTimestamps({});
          const gamepads = navigator.getGamepads();
          const connectedCount = controllerConnected.filter(c => c).length;
          const newPositions = new Array(connectedCount).fill('未指派');
          const newIndexMap = {};
          for (let i = 0, count = 1; i < gamepads.length; i++) {
            if (gamepads[i] && controllerConnected[i]) {
              newPositions[i] = `J${count}`;
              newIndexMap[i] = newPositions[i];
              count++;
            }
          }
          setControllerPositions(newPositions);
          setControllerIndexMap(newIndexMap);
          setTempControllerPositions(newPositions);
          setTempManualPositions(new Array(connectedCount).fill('未輸入'));
        };

        const pollGamepads = () => {
          const gamepads = navigator.getGamepads();
          const newButtonStates = {};
          const newButtonPressTimestamps = { ...buttonPressTimestamps };
          let requiredPresses = matchMode && !bypassMatchMode ? controllerCount : 1;
          let mainControllerButtons = { options: false, share: false, touchpad: false, L3: false, R3: false, up: false, down: false, left: false, right: false, circle: false, cross: false, triangle: false, square: false, L1: false, L2: false, R1: false, R2: false };
          const currentTime = Date.now();
          
          let mainControllerIndex = -1;
          for (let i = 1; i <= controllerConnected.length; i++) {
            const jIndex = controllerPositions.findIndex(pos => pos === `J${i}`);
            if (jIndex !== -1 && controllerConnected[jIndex]) {
              mainControllerIndex = jIndex;
              break;
            }
          }

          for (let i = 0; i < gamepads.length; i++) {
            if (!newButtonPressTimestamps[i]) newButtonPressTimestamps[i] = {};
            ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options', 'L3', 'R3'].forEach(button => {
              if (!newButtonPressTimestamps[i][button]) newButtonPressTimestamps[i][button] = [];
            });
          }

          for (let i = 0; i < gamepads.length; i++) {
            const gamepad = gamepads[i];
            if (gamepad) {
              const buttons = gamepad.buttons;
              const position = controllerPositions[i] || `J${i + 1}`;
              newButtonStates[i] = {
                L1: buttons[4].pressed,
                L2: buttons[6].pressed,
                R1: buttons[5].pressed,
                R2: buttons[7].pressed,
                up: buttons[12].pressed,
                right: buttons[15].pressed,
                down: buttons[13].pressed,
                left: buttons[14].pressed,
                triangle: buttons[3].pressed,
                square: buttons[2].pressed,
                cross: buttons[0].pressed,
                circle: buttons[1].pressed,
                L3: buttons[10].pressed,
                R3: buttons[11].pressed,
                options: buttons[9].pressed,
                share: buttons[8].pressed,
                touchpad: buttons[17]?.pressed || false,
              };

              if (i === mainControllerIndex) {
                mainControllerButtons = newButtonStates[i];
              }

              if (!settingsOpen && !result && !overtimeOpen) {
                const updateTimestamps = (button) => {
                  if (newButtonStates[i][button] && !buttonStates[i]?.[button]) {
                    newButtonPressTimestamps[i][button].push(currentTime);
                    if (['up', 'L1', 'L2', 'right', 'left'].includes(button)) {
                      setLeftButtonFlash(prev => ({
                        ...prev,
                        [i]: { ...prev[i], [button]: true }
                      }));
                      setTimeout(() => {
                        setLeftButtonFlash(prev => ({
                          ...prev,
                          [i]: { ...prev[i], [button]: false }
                        }));
                      }, 300);
                    }
                    if (['triangle', 'square', 'R2', 'R1', 'circle'].includes(button)) {
                      setRightButtonFlash(prev => ({
                        ...prev,
                        [i]: { ...prev[i], [button]: true }
                      }));
                      setTimeout(() => {
                        setRightButtonFlash(prev => ({
                          ...prev,
                          [i]: { ...prev[i], [button]: false }
                        }));
                      }, 300);
                    }
                  }
                };

                ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options', 'L3', 'R3'].forEach(button => {
                  updateTimestamps(button);
                });
              }
            }
          }

          for (let i = 0; i < gamepads.length; i++) {
            if (newButtonPressTimestamps[i]) {
              ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options', 'L3', 'R3'].forEach(button => {
                newButtonPressTimestamps[i][button] = newButtonPressTimestamps[i][button].filter(ts => currentTime - ts <= 1000);
              });
            }
          }

          if (isEditingManualPosition && mainControllerIndex !== -1) {
            if (newButtonStates[mainControllerIndex].circle && !buttonStates[mainControllerIndex]?.circle) {
              const usedPositions = tempManualPositions.filter(p => p !== '未輸入');
              const hasDuplicate = new Set(usedPositions).size !== usedPositions.length;
              const hasJ1 = tempManualPositions.includes('J1');
              if (!hasDuplicate && hasJ1) {
                setControllerPositions(tempManualPositions);
                setControllerIndexMap(prevMap => {
                  const newMap = {};
                  tempManualPositions.forEach((pos, idx) => {
                    if (pos !== '未輸入') {
                      newMap[idx] = pos;
                    }
                  });
                  return newMap;
                });
                setIsEditingManualPosition(false);
                setIsEditingBasicSettings(true);
                setBasicSettingsOption(4);
                setManualPositionOrder([]);
                setTempManualPositions(new Array(controllerConnected.filter(c => c).length).fill('未輸入'));
                triggerVibration(gamepads[mainControllerIndex]);
              } else {
                triggerVibration(gamepads[mainControllerIndex]);
              }
            }
            if (newButtonStates[mainControllerIndex].cross && !buttonStates[mainControllerIndex]?.cross) {
              setIsEditingManualPosition(false);
              setIsEditingBasicSettings(true);
              setBasicSettingsOption(4);
              setManualPositionOrder([]);
              setTempManualPositions(new Array(controllerConnected.filter(c => c).length).fill('未輸入'));
              triggerVibration(gamepads[mainControllerIndex]);
            }
            if (newButtonStates[mainControllerIndex].square && !buttonStates[mainControllerIndex]?.square) {
              setManualPositionOrder([]);
              setTempManualPositions(new Array(controllerConnected.filter(c => c).length).fill('未輸入'));
              triggerVibration(gamepads[mainControllerIndex]);
            }
            ['up', 'down', 'left', 'right'].forEach(button => {
              if (newButtonStates[mainControllerIndex][button] && !buttonStates[mainControllerIndex]?.[button]) {
                // 不執行任何操作，防止影響其他設置
              }
            });
          }

          for (let i = 0; i < gamepads.length; i++) {
            const gamepad = gamepads[i];
            if (gamepad && isEditingManualPosition && newButtonStates[i]?.triangle && !buttonStates[i]?.triangle) {
              const currentOrderLength = manualPositionOrder.length;
              const connectedCount = controllerConnected.filter(c => c).length;
              if (currentOrderLength < connectedCount && !manualPositionOrder.includes(i)) {
                setManualPositionOrder(prev => [...prev, i]);
                setTempManualPositions(prev => {
                  const newPositions = [...prev];
                  newPositions[i] = `J${currentOrderLength + 1}`;
                  return newPositions;
                });
                triggerVibration(gamepad);
              }
            }
          }

          const checkSimultaneousPresses = (button, points, side, setScore, setLog, setHistory, prevScore, prevHearts) => {
            let presses = [];
            for (let i = 0; i < gamepads.length; i++) {
              if (newButtonPressTimestamps[i]?.[button]?.length > 0) {
                newButtonPressTimestamps[i][button].forEach(ts => {
                  if (currentTime - ts <= 1000) {
                    presses.push({ index: i, position: controllerPositions[i] || `J${i + 1}`, timestamp: ts });
                  }
                });
              }
            }

            if (matchMode && !bypassMatchMode) {
              presses.sort((a, b) => a.timestamp - b.timestamp);
              while (presses.length >= requiredPresses) {
                const matchedControllers = [];
                const matchedTimestamps = [];
                let earliestTimestamp = presses[0].timestamp;

                let uniqueControllers = new Set();
                for (let i = 0; i < presses.length && uniqueControllers.size < requiredPresses; i++) {
                  if (Math.abs(presses[i].timestamp - earliestTimestamp) <= 1000 && !uniqueControllers.has(presses[i].index)) {
                    matchedControllers.push(presses[i]);
                    matchedTimestamps.push(presses[i].timestamp);
                    uniqueControllers.add(presses[i].index);
                  }
                }

                if (matchedControllers.length >= requiredPresses) {
                  const positions = matchedControllers.map(p => p.position).sort().join('/');
                  setScore(prev => {
                    setHistory(prevHistory => [...prevHistory, { side, type: 'score', points, prevScore, prevHearts }]);
                    setLog(prevLog => [`${positions}:+${points}`, ...prevLog].slice(0, 15));
                    matchedControllers.forEach(p => triggerVibration(gamepads[p.index]));
                    return prev + points;
                  });

                  matchedControllers.forEach(p => {
                    const idx = newButtonPressTimestamps[p.index][button].indexOf(p.timestamp);
                    if (idx !== -1) {
                      newButtonPressTimestamps[p.index][button].splice(idx, 1);
                    }
                  });
                  presses = presses.filter(p => !matchedTimestamps.includes(p.timestamp));
                } else {
                  break;
                }
              }
            } else {
              presses.forEach(p => {
                if (bypassMatchMode && controllerPositions[p.index] !== 'J1') {
                  return;
                }
                setScore(prev => {
                  setHistory(prevHistory => [...prevHistory, { side, type: 'score', points, prevScore, prevHearts }]);
                  setLog(prevLog => [`${p.position}:+${points}`, ...prevLog].slice(0, 15));
                  triggerVibration(gamepads[p.index]);
                  const idx = newButtonPressTimestamps[p.index][button].indexOf(p.timestamp);
                  if (idx !== -1) {
                    newButtonPressTimestamps[p.index][button].splice(idx, 1);
                  }
                  if (bypassMatchMode) {
                    setBypassMatchMode(false);
                  }
                  return prev + points;
                });
              });
            }
          };

          if (!result && !settingsOpen && !overtimeOpen) {
            checkSimultaneousPresses('L1', 2, 'left', setLeftScore, setLeftLog, setLeftHistory, leftScore, leftHearts);
            checkSimultaneousPresses('L2', 3, 'left', setLeftScore, setLeftLog, setLeftHistory, leftScore, leftHearts);
            checkSimultaneousPresses('up', 1, 'left', setLeftScore, setLeftLog, setLeftHistory, leftScore, leftHearts);
            checkSimultaneousPresses('right', 4, 'left', setLeftScore, setLeftLog, setLeftHistory, leftScore, leftHearts);
            checkSimultaneousPresses('left', 5, 'left', setLeftScore, setLeftLog, setLeftHistory, leftScore, leftHearts);
            checkSimultaneousPresses('R1', 2, 'right', setRightScore, setRightLog, setRightHistory, rightScore, rightHearts);
            checkSimultaneousPresses('R2', 3, 'right', setRightScore, setRightLog, setRightHistory, rightScore, rightHearts);
            checkSimultaneousPresses('triangle', 1, 'right', setRightScore, setRightLog, setRightHistory, rightScore, rightHearts);
            checkSimultaneousPresses('square', 4, 'right', setRightScore, setRightLog, setRightHistory, rightScore, rightHearts);
            checkSimultaneousPresses('circle', 5, 'right', setRightScore, setRightLog, setRightHistory, rightScore, rightHearts);
          }

          if (mainControllerIndex !== -1 && !result && !settingsOpen && !overtimeOpen) {
            if (mainControllerButtons.down && !buttonStates[mainControllerIndex]?.down) {
              setLeftHearts(prev => {
                const newHearts = Math.max(0, prev - 1);
                setRightHistory(prevHistory => [...prevHistory, { side: 'left', type: 'heart', points: 1, prevScore: rightScore, prevHearts: prev }]);
                setRightScore(prevScore => {
                  setRightLog(prevLog => [`${controllerPositions[mainControllerIndex] || 'J1'}:*+1`, ...prevLog].slice(0, 15));
                  triggerVibration(gamepads[mainControllerIndex]);
                  if (newButtonPressTimestamps[mainControllerIndex]) newButtonPressTimestamps[mainControllerIndex].down = [];
                  return prevScore + 1;
                });
                return newHearts;
              });
            }
            if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
              setRightHearts(prev => {
                const newHearts = Math.max(0, prev - 1);
                setLeftHistory(prevHistory => [...prevHistory, { side: 'right', type: 'heart', points: 1, prevScore: leftScore, prevHearts: prev }]);
                setLeftScore(prevScore => {
                  setLeftLog(prevLog => [`${controllerPositions[mainControllerIndex] || 'J1'}:*+1`, ...prevLog].slice(0, 15));
                  triggerVibration(gamepads[mainControllerIndex]);
                  if (newButtonPressTimestamps[mainControllerIndex]) newButtonPressTimestamps[mainControllerIndex].cross = [];
                  return prevScore + 1;
                });
                return newHearts;
              });
            }

            if (mainControllerButtons.L3 && mainControllerButtons.R3 &&
                (!buttonStates[mainControllerIndex]?.L3 || !buttonStates[mainControllerIndex]?.R3)) {
              setLeftScore(0);
              setRightScore(0);
              setLeftHearts(5);
              setRightHearts(5);
              setLeftHistory([]);
              setRightHistory([]);
              setLeftLog([]);
              setRightLog([]);
              setResult('');
              setTimerSeconds(countdownTime);
              setTimerMilliseconds(0);
              setIsTimerRunning(false);
              setOvertimeOpen(false);
              setHeartTerminationTriggered(false);
              setScoreDiff12Triggered(false);
              setButtonPressTimestamps({});
              setBypassMatchMode(false);
              triggerVibration(gamepads[mainControllerIndex]);
            }

            if (mainControllerButtons.R3 && !buttonStates[mainControllerIndex]?.R3 && !mainControllerButtons.L3) {
              const lastRightEntry = rightHistory.slice(-1)[0];
              if (lastRightEntry) {
                if (lastRightEntry.type === 'score' && lastRightEntry.side === 'right') {
                  setRightScore(lastRightEntry.prevScore);
                  setRightLog(prevLog => prevLog.slice(1));
                } else if (lastRightEntry.type === 'heart' && lastRightEntry.side === 'left') {
                  setRightScore(lastRightEntry.prevScore);
                  setRightLog(prevLog => prevLog.slice(1));
                  setLeftHearts(lastRightEntry.prevHearts);
                  if (lastRightEntry.prevHearts > 0 && leftHearts === 0) {
                    setHeartTerminationTriggered(false);
                    setResult('');
                  }
                }
                setRightHistory(prevHistory => prevHistory.slice(0, -1));
                if (scoreDiff12 === 'on' && Math.abs(leftScore - (lastRightEntry.side === 'right' ? lastRightEntry.prevScore : rightScore)) < 12) {
                  setScoreDiff12Triggered(false);
                } else if (scoreDiff12 === 'golden' && leftScore < 2 && (lastRightEntry.side === 'right' ? lastRightEntry.prevScore : rightScore) < 2) {
                  setScoreDiff12Triggered(false);
                }
                triggerVibration(gamepads[mainControllerIndex]);
              }
            }

            if (mainControllerButtons.L3 && !buttonStates[mainControllerIndex]?.L3 && !mainControllerButtons.R3) {
              const lastLeftEntry = leftHistory.slice(-1)[0];
              if (lastLeftEntry) {
                if (lastLeftEntry.type === 'score' && lastLeftEntry.side === 'left') {
                  setLeftScore(lastLeftEntry.prevScore);
                  setLeftLog(prevLog => prevLog.slice(1));
                } else if (lastLeftEntry.type === 'heart' && lastLeftEntry.side === 'right') {
                  setLeftScore(lastLeftEntry.prevScore);
                  setLeftLog(prevLog => prevLog.slice(1));
                  setRightHearts(lastLeftEntry.prevHearts);
                  if (lastRightEntry.prevHearts > 0 && rightHearts === 0) {
                    setHeartTerminationTriggered(false);
                    setResult('');
                  }
                }
                setLeftHistory(prevHistory => prevHistory.slice(0, -1));
                if (scoreDiff12 === 'on' && Math.abs(lastLeftEntry.side === 'left' ? lastLeftEntry.prevScore - rightScore : leftScore - rightScore) < 12) {
                  setScoreDiff12Triggered(false);
                } else if (scoreDiff12 === 'golden' && (lastLeftEntry.side === 'left' ? lastLeftEntry.prevScore : leftScore) < 2 && rightScore < 2) {
                  setScoreDiff12Triggered(false);
                }
                triggerVibration(gamepads[mainControllerIndex]);
              }
            }

            if (mainControllerButtons.options && !buttonStates[mainControllerIndex]?.options) {
              setSettingsOpen(true);
              setIsTimerRunning(false);
              if (newButtonPressTimestamps[mainControllerIndex]) newButtonPressTimestamps[mainControllerIndex].options = [];
              triggerVibration(gamepads[mainControllerIndex]);
            }

            if (mainControllerButtons.share && !buttonStates[mainControllerIndex]?.share) {
              setResult(determineWinner());
              setIsTimerRunning(false);
              setHeartTerminationTriggered(true);
              setScoreDiff12Triggered(true);
            }

            if (mainControllerButtons.touchpad && !buttonStates[mainControllerIndex]?.touchpad && timerOn) {
              setIsTimerRunning(prev => {
                if (!prev && timerSeconds === 0 && timerMilliseconds === 0) {
                  setTimerSeconds(countdownTime);
                  setTimerMilliseconds(0);
                }
                return !prev;
              });
            }
          }

          if (mainControllerIndex !== -1 && settingsOpen && mainControllerButtons.L1 && mainControllerButtons.R1 && 
              (!buttonStates[mainControllerIndex]?.L1 || !buttonStates[mainControllerIndex]?.R1)) {
            setBypassMatchMode(true);
            setSettingsOpen(false);
            triggerVibration(gamepads[mainControllerIndex]);
          }

          if ((settingsOpen && !prevSettingsOpen) || (result && !prevResult) || (overtimeOpen && !prevOvertimeOpen)) {
            for (let i = 0; i < gamepads.length; i++) {
              if (newButtonPressTimestamps[i]) {
                ['L1', 'L2', 'up', 'right', 'left', 'down', 'R1', 'R2', 'triangle', 'square', 'circle', 'cross', 'options', 'L3', 'R3'].forEach(button => {
                  newButtonPressTimestamps[i][button] = [];
                });
              }
            }
          }

          if (mainControllerIndex !== -1 && result) {
            if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
              setResult('');
              if (scoreDiff12 === 'on' && Math.abs(leftScore - rightScore) < 12) {
                setScoreDiff12Triggered(false);
              } else if (scoreDiff12 === 'golden' && leftScore < 2 && rightScore < 2) {
                setScoreDiff12Triggered(false);
              }
            } else if (result === '平手，請選擇勝方') {
              if (mainControllerButtons.left && !buttonStates[mainControllerIndex]?.left) {
                setResult('藍方勝');
              }
              if (mainControllerButtons.right && !buttonStates[mainControllerIndex]?.right) {
                setResult('紅方勝');
              }
            }
          }

          if (mainControllerIndex !== -1 && overtimeOpen) {
            if (mainControllerButtons.triangle && !buttonStates[mainControllerIndex]?.triangle) {
              setResult(determineWinner());
              setOvertimeOpen(false);
              setHeartTerminationTriggered(true);
              setScoreDiff12Triggered(true);
            }
            if (mainControllerButtons.circle && !buttonStates[mainControllerIndex]?.circle) {
              setTimerSeconds(overtimeSeconds);
              setTimerMilliseconds(0);
              setOvertimeOpen(false);
              setIsTimerRunning(true);
            }
            if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
              setOvertimeOpen(false);
            }
            if (mainControllerButtons.left && !buttonStates[mainControllerIndex]?.left) {
              setOvertimeSeconds(prev => Math.max(5, prev - 5));
            }
            if (mainControllerButtons.right && !buttonStates[mainControllerIndex]?.right) {
              setOvertimeSeconds(prev => Math.min(60, prev + 5));
            }
          }

          if (mainControllerIndex !== -1 && settingsOpen && !isEditingManualPosition) {
            const matchSettingsMaxOption = timerOn ? (matchMode ? 5 : 4) : (matchMode ? 4 : 3);
            const basicSettingsMaxOption = 4;
            if (!isEditingTime && !isEditingManual && !isEditingPosition && !isEditingBasicSettings && !isEditingMatchSettings) {
              if (mainControllerButtons.up && !buttonStates[mainControllerIndex]?.up) {
                setSelectedOption(prev => (prev === 0 ? 1 : 0));
              }
              if (mainControllerButtons.down && !buttonStates[mainControllerIndex]?.down) {
                setSelectedOption(prev => (prev === 1 ? 0 : 1));
              }
              if (mainControllerButtons.circle && !buttonStates[mainControllerIndex]?.circle) {
                if (selectedOption === 0) {
                  setIsEditingMatchSettings(true);
                  setMatchSettingsOption(0);
                } else if (selectedOption === 1) {
                  setIsEditingBasicSettings(true);
                  setBasicSettingsOption(0);
                }
              }
              if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
                setSettingsOpen(false);
                setSelectedOption(0);
              }
            } else if (isEditingMatchSettings && !isEditingTime && !isEditingManual && !isEditingPosition) {
              if (mainControllerButtons.up && !buttonStates[mainControllerIndex]?.up) {
                setMatchSettingsOption(prev => (prev === 0 ? matchSettingsMaxOption : prev - 1));
              }
              if (mainControllerButtons.down && !buttonStates[mainControllerIndex]?.down) {
                setMatchSettingsOption(prev => (prev === matchSettingsMaxOption ? 0 : prev + 1));
              }
              if (mainControllerButtons.circle && !buttonStates[mainControllerIndex]?.circle) {
                if (timerOn && matchSettingsOption === 1) {
                  setIsEditingManual(true);
                  setTempManualMinutes(Math.floor(countdownTime / 60));
                  setTempManualSeconds(countdownTime % 60);
                  setEditingDigit(0);
                }
              }
              if (mainControllerButtons.left && !buttonStates[mainControllerIndex]?.left) {
                if (matchSettingsOption === 0) {
                  setTimerOn(prev => {
                    const newTimerOn = !prev;
                    if (!newTimerOn) {
                      setIsTimerRunning(false);
                      setTimerSeconds(countdownTime);
                      setTimerMilliseconds(0);
                    }
                    return newTimerOn;
                  });
                } else if (timerOn && matchSettingsOption === 1) {
                  setCountdownTime(prev => {
                    const newTime = Math.min(5999, prev + 15);
                    setTimerSeconds(newTime);
                    setTimerMilliseconds(0);
                    setIsTimerRunning(false);
                    return newTime;
                  });
                } else if (matchSettingsOption === (timerOn ? 2 : 1)) {
                  setHeartTermination(prev => !prev);
                } else if (matchSettingsOption === (timerOn ? 3 : 2)) {
                  setScoreDiff12(prev => {
                    const options = ['off', 'on', 'golden'];
                    const currentIndex = options.indexOf(prev);
                    return options[(currentIndex + 2) % 3];
                  });
                } else if (matchSettingsOption === (timerOn ? 4 : 3)) {
                  setMatchMode(prev => !prev);
                } else if (matchMode && matchSettingsOption === (timerOn ? 5 : 4)) {
                  setControllerCount(prev => Math.max(1, prev - 1));
                }
              }
              if (mainControllerButtons.right && !buttonStates[mainControllerIndex]?.right) {
                if (matchSettingsOption === 0) {
                  setTimerOn(prev => {
                    const newTimerOn = !prev;
                    if (!newTimerOn) {
                      setIsTimerRunning(false);
                      setTimerSeconds(countdownTime);
                      setTimerMilliseconds(0);
                    }
                    return newTimerOn;
                  });
                } else if (timerOn && matchSettingsOption === 1) {
                  setCountdownTime(prev => {
                    const newTime = Math.max(0, prev - 15);
                    setTimerSeconds(newTime);
                    setTimerMilliseconds(0);
                    setIsTimerRunning(false);
                    return newTime;
                  });
                } else if (matchSettingsOption === (timerOn ? 2 : 1)) {
                  setHeartTermination(prev => !prev);
                } else if (matchSettingsOption === (timerOn ? 3 : 2)) {
                  setScoreDiff12(prev => {
                    const options = ['off', 'on', 'golden'];
                    const currentIndex = options.indexOf(prev);
                    return options[(currentIndex + 1) % 3];
                  });
                } else if (matchSettingsOption === (timerOn ? 4 : 3)) {
                  setMatchMode(prev => !prev);
                } else if (matchMode && matchSettingsOption === (timerOn ? 5 : 4)) {
                  setControllerCount(prev => Math.min(5, prev + 1));
                }
              }
              if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
                setIsEditingMatchSettings(false);
                setMatchSettingsOption(0);
              }
            } else if (isEditingManual) {
              if (mainControllerButtons.left && !buttonStates[mainControllerIndex]?.left) {
                setEditingDigit(prev => Math.max(0, prev - 1));
              }
              if (mainControllerButtons.right && !buttonStates[mainControllerIndex]?.right) {
                setEditingDigit(prev => Math.min(3, prev + 1));
              }
              if (mainControllerButtons.up && !buttonStates[mainControllerIndex]?.up) {
                if (editingDigit === 0) {
                  setTempManualMinutes(prev => {
                    const tens = (Math.floor(prev / 10) + 1) % 10;
                    const ones = prev % 10;
                    return Math.min(99, tens * 10 + ones);
                  });
                } else if (editingDigit === 1) {
                  setTempManualMinutes(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 1) % 10;
                    return Math.min(99, tens * 10 + ones);
                  });
                } else if (editingDigit === 2) {
                  setTempManualSeconds(prev => {
                    const tens = (Math.floor(prev / 10) + 1) % 6;
                    const ones = prev % 10;
                    return Math.min(59, tens * 10 + ones);
                  });
                } else if (editingDigit === 3) {
                  setTempManualSeconds(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 1) % 10;
                    return Math.min(59, tens * 10 + ones);
                  });
                }
              }
              if (mainControllerButtons.down && !buttonStates[mainControllerIndex]?.down) {
                if (editingDigit === 0) {
                  setTempManualMinutes(prev => {
                    const tens = (Math.floor(prev / 10) + 9) % 10;
                    const ones = prev % 10;
                    return tens * 10 + ones;
                  });
                } else if (editingDigit === 1) {
                  setTempManualMinutes(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 9) % 10;
                    return tens * 10 + ones;
                  });
                } else if (editingDigit === 2) {
                  setTempManualSeconds(prev => {
                    const tens = (Math.floor(prev / 10) + 5) % 6;
                    const ones = prev % 10;
                    return tens * 10 + ones;
                  });
                } else if (editingDigit === 3) {
                  setTempManualSeconds(prev => {
                    const tens = Math.floor(prev / 10);
                    const ones = (prev % 10 + 9) % 10;
                    return tens * 10 + ones;
                  });
                }
              }
              if (mainControllerButtons.circle && !buttonStates[mainControllerIndex]?.circle) {
                const newTime = tempManualMinutes * 60 + tempManualSeconds;
                setCountdownTime(newTime);
                setTimerSeconds(newTime);
                setTimerMilliseconds(0);
                setIsEditingManual(false);
                setEditingDigit(0);
                setIsEditingTime(false);
              }
              if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
                setIsEditingManual(false);
                setEditingDigit(0);
                setIsEditingTime(false);
              }
            } else if (isEditingPosition) {
              if (mainControllerButtons.up && !buttonStates[mainControllerIndex]?.up) {
                setEditingController(prev => {
                  const connectedCount = controllerConnected.filter(c => c).length;
                  return prev === 0 ? connectedCount - 1 : prev - 1;
                });
              }
              if (mainControllerButtons.down && !buttonStates[mainControllerIndex]?.down) {
                setEditingController(prev => {
                  const connectedCount = controllerConnected.filter(c => c).length;
                  return prev === connectedCount - 1 ? 0 : prev + 1;
                });
              }
              if (mainControllerButtons.left && !buttonStates[mainControllerIndex]?.left) {
                setTempControllerPositions(prev => {
                  const newPositions = [...prev];
                  const availableOptions = getAvailableOptions(editingController).filter(opt => !opt.isDisabled).map(opt => opt.value);
                  const currentIndex = availableOptions.indexOf(newPositions[editingController]);
                  const nextIndex = (currentIndex - 1 + availableOptions.length) % availableOptions.length;
                  newPositions[editingController] = availableOptions[nextIndex];
                  return newPositions;
                });
              }
              if (mainControllerButtons.right && !buttonStates[mainControllerIndex]?.right) {
                setTempControllerPositions(prev => {
                  const newPositions = [...prev];
                  const availableOptions = getAvailableOptions(editingController).filter(opt => !opt.isDisabled).map(opt => opt.value);
                  const currentIndex = availableOptions.indexOf(newPositions[editingController]);
                  const nextIndex = (currentIndex + 1) % availableOptions.length;
                  newPositions[editingController] = availableOptions[nextIndex];
                  return newPositions;
                });
              }
              if (mainControllerButtons.circle && !buttonStates[mainControllerIndex]?.circle) {
                const usedPositions = tempControllerPositions.filter(p => p !== '未指派');
                const hasDuplicate = new Set(usedPositions).size !== usedPositions.length;
                const hasJ1 = tempControllerPositions.includes('J1');
                if (!hasDuplicate && hasJ1) {
                  setControllerPositions(tempControllerPositions);
                  setControllerIndexMap(prevMap => {
                    const newMap = {};
                    tempControllerPositions.forEach((pos, idx) => {
                      if (pos !== '未指派') {
                        newMap[idx] = pos;
                      }
                    });
                    return newMap;
                  });
                  setIsEditingPosition(false);
                  setEditingController(0);
                  triggerVibration(gamepads[mainControllerIndex]);
                } else {
                  triggerVibration(gamepads[mainControllerIndex]);
                }
              }
              if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
                setIsEditingPosition(false);
                setEditingController(0);
                setTempControllerPositions(new Array(controllerConnected.filter(c => c).length).fill('未指派'));
              }
            } else if (isEditingBasicSettings) {
              if (mainControllerButtons.up && !buttonStates[mainControllerIndex]?.up) {
                setBasicSettingsOption(prev => (prev === 0 ? basicSettingsMaxOption : prev - 1));
              }
              if (mainControllerButtons.down && !buttonStates[mainControllerIndex]?.down) {
                setBasicSettingsOption(prev => (prev === basicSettingsMaxOption ? 0 : prev + 1));
              }
              if (mainControllerButtons.left && !buttonStates[mainControllerIndex]?.left) {
                if (basicSettingsOption === 0) {
                  setVibrationOn(prev => !prev);
                } else if (basicSettingsOption === 1) {
                  setHelpTextOn(prev => !prev);
                }
              }
              if (mainControllerButtons.right && !buttonStates[mainControllerIndex]?.right) {
                if (basicSettingsOption === 0) {
                  setVibrationOn(prev => !prev);
                } else if (basicSettingsOption === 1) {
                  setHelpTextOn(prev => !prev);
                }
              }
              if (mainControllerButtons.circle && !buttonStates[mainControllerIndex]?.circle) {
                if (basicSettingsOption === 2) {
                  setIsEditingPosition(true);
                  setEditingController(0);
                  setTempControllerPositions(controllerPositions.slice(0, controllerConnected.filter(c => c).length));
                } else if (basicSettingsOption === 3) {
                  resetControllerPositions();
                  triggerVibration(gamepads[mainControllerIndex]);
                } else if (basicSettingsOption === 4) {
                  setIsEditingManualPosition(true);
                  setManualPositionOrder([]);
                  setTempManualPositions(new Array(controllerConnected.filter(c => c).length).fill('未輸入'));
                  triggerVibration(gamepads[mainControllerIndex]);
                }
              }
              if (mainControllerButtons.cross && !buttonStates[mainControllerIndex]?.cross) {
                setIsEditingBasicSettings(false);
                setBasicSettingsOption(0);
              }
            }
          }

          if (scoreDiff12 === 'on' && !result && !scoreDiff12Triggered && Math.abs(leftScore - rightScore) >= 12) {
            setResult(determineWinner());
            setIsTimerRunning(false);
            setScoreDiff12Triggered(true);
            setHeartTerminationTriggered(true);
          } else if (scoreDiff12 === 'golden' && !result && !scoreDiff12Triggered && (leftScore >= 2 || rightScore >= 2)) {
            setResult(determineWinner());
            setIsTimerRunning(false);
            setScoreDiff12Triggered(true);
            setHeartTerminationTriggered(true);
          }

          if (heartTermination && !result && !heartTerminationTriggered && (leftHearts === 0 || rightHearts === 0)) {
            setResult(determineWinner());
            setIsTimerRunning(false);
            setHeartTerminationTriggered(true);
            setScoreDiff12Triggered(true);
          }

          prevSettingsOpen = settingsOpen;
          prevResult = result;
          prevOvertimeOpen = overtimeOpen;

          setButtonStates(newButtonStates);
          setButtonPressTimestamps(newButtonPressTimestamps);
        };

        let prevSettingsOpen = settingsOpen;
        let prevResult = result;
        let prevOvertimeOpen = overtimeOpen;

        const interval = setInterval(pollGamepads, 50);
        return () => {
          clearInterval(interval);
          window.removeEventListener('gamepadconnected', handleGamepadConnected);
          window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
        };
      }, [leftHistory, rightHistory, buttonStates, buttonPressTimestamps, settingsOpen, overtimeOpen, result, countdownTime, selectedOption, isEditingTime, isEditingManual, isEditingPosition, isEditingBasicSettings, isEditingMatchSettings, isEditingManualPosition, matchSettingsOption, basicSettingsOption, heartTermination, heartTerminationTriggered, vibrationOn, helpTextOn, matchMode, controllerCount, controllerPositions, controllerIndexMap, scoreDiff12, scoreDiff12Triggered, leftScore, rightScore, leftHearts, rightHearts, disconnectedTimestamps, manualPositionOrder, tempManualPositions, bypassMatchMode]);

      const formatTimer = (seconds, milliseconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        const ms = Math.floor(milliseconds / 10);
        return (
          <span>
            <span className="text-[8rem]">{`${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`}</span>
            <span className="text-[4rem]">{`:${ms.toString().padStart(2, '0')}`}</span>
          </span>
        );
      };

      const formatCountdownTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      };

      const getDigits = () => {
        const minutesTens = Math.floor(tempManualMinutes / 10);
        const minutesOnes = tempManualMinutes % 10;
        const secondsTens = Math.floor(tempManualSeconds / 10);
        const secondsOnes = tempManualSeconds % 10;
        return [minutesTens, minutesOnes, secondsTens, secondsOnes];
      };

      const getAvailableOptions = (currentIndex) => {
        const connectedCount = controllerConnected.filter(c => c).length;
        const options = ['未指派', ...Array(connectedCount).fill().map((_, i) => `J${i + 1}`)];
        const usedPositions = tempControllerPositions.filter((_, i) => i !== currentIndex && tempControllerPositions[i] !== '未指派');
        return options.map(option => ({
          value: option,
          isDisabled: usedPositions.includes(option) && option !== '未指派'
        }));
      };

      const sortedControllerIndices = controllerConnected
        .map((connected, index) => connected ? index : null)
        .filter(index => index !== null)
        .sort((a, b) => {
          const posA = controllerPositions[a] || `J${a + 1}`;
          const posB = controllerPositions[b] || `J${b + 1}`;
          if (posA === 'J1') return -1;
          if (posB === 'J1') return 1;
          if (posA === '未指派') return 1;
          if (posB === '未指派') return -1;
          const numA = parseInt(posA.replace('J', '')) || Number.MAX_SAFE_INTEGER;
          const numB = parseInt(posB.replace('J', '')) || Number.MAX_SAFE_INTEGER;
          return numA - numB;
        });

      return (
        <div className="flex flex-1 min-h-screen relative">
          {helpTextOn ? (
            <div className="absolute left-4 top-4 text-sm flex flex-col space-y-1 min-h-[100px] min-w-[150px]">
              <p className={timerOn ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                計時: {timerOn ? "開" : "關"}
              </p>
              <p className={heartTermination ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                Gam-jeom: {heartTermination ? "開" : "關"}
              </p>
              <p className={scoreDiff12 !== 'off' ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                分差模式: {scoreDiff12 === 'off' ? '關' : scoreDiff12 === 'on' ? '12分差' : '黃金得分'}
              </p>
              <p className={matchMode ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                比賽模式: {matchMode ? "開" : "關"}
              </p>
              {matchMode && (
                <p className="text-white bg-gray-800 px-2 py-1 rounded">
                  同時按分: {controllerCount}
                </p>
              )}
              <p className={bypassMatchMode ? "text-green-400 bg-gray-800 px-2 py-1 rounded" : "text-red-400 bg-gray-800 px-2 py-1 rounded"}>
                繞過比賽模式: {bypassMatchMode ? "開" : "關"}
              </p>
            </div>
          ) : (
            <div className="absolute left-4 top-4 min-h-[100px] min-w-[150px]"></div>
          )}
          <div className="absolute left-4 top-1/4 text-sm flex flex-col items-start max-w-[150px] min-h-[100px]">
            <p>得分記錄:</p>
            {leftLog.length > 0 && (
              <ul>
                {leftLog.map((entry, index) => (
                  <li key={index}>{entry}</li>
                ))}
              </ul>
            )}
          </div>
          <div className="absolute left-4 bottom-[84px] text-sm flex flex-col items-end max-w-[150px]">
            {sortedControllerIndices.map(i => (
              <div key={i} className="flex items-end space-x-1 w-[120px]">
                <span className="w-8 text-right">{controllerPositions[i] || `J${i + 1}`}</span>
                <span className="flex space-x-1">
                  {['up', 'L1', 'L2', 'right', 'left'].map(button => (
                    <span key={button} className={leftButtonFlash[i]?.[button] ? "bg-green-400 w-4 h-4 animate-pulse" : "bg-gray-800 w-4 h-4"}></span>
                  ))}
                </span>
              </div>
            ))}
          </div>
          <div className="flex-1 bg-blue-600 flex flex-col items-center justify-center space-y-6">
            <h2 className="text-2xl">藍方分數</h2>
            <p className="text-[24rem] font-bold">{leftScore}</p>
            <p className="text-[2rem] flex space-x-4 bg-black p-2 rounded min-h-[40px]">{Array(leftHearts).fill('❤️').join('x')}</p>
            {helpTextOn ? (
              <p className="text-sm min-h-[20px]">上: +1, L1: +2, L2: +3, 右: +4, 左: +5, 主控下: 藍心-1紅分+1, 主控 L3: 復原藍方</p>
            ) : (
              <p className="min-h-[20px]"></p>
            )}
          </div>
          <div className="flex-1 bg-red-600 flex flex-col items-center justify-center space-y-6">
            <h2 className="text-2xl">紅方分數</h2>
            <p className="text-[24rem] font-bold">{rightScore}</p>
            <p className="text-[2rem] flex space-x-4 bg-black p-2 rounded min-h-[40px]">{Array(rightHearts).fill('❤️').join('x')}</p>
            {helpTextOn ? (
              <p className="text-sm min-h-[20px]">三角: +1, R1: +2, R2: +3, 方: +4, 圓圈: +5, 主控交叉: 紅心-1藍分+1, 主控 R3: 復原紅方</p>
            ) : (
              <p className="min-h-[20px]"></p>
            )}
          </div>
          <div className="absolute right-4 top-1/4 text-sm flex flex-col items-start max-w-[150px] min-h-[100px]">
            <p>得分記錄:</p>
            {rightLog.length > 0 && (
              <ul>
                {rightLog.map((entry, index) => (
                  <li key={index}>{entry}</li>
                ))}
              </ul>
            )}
          </div>
          <div className="absolute right-4 bottom-[84px] text-sm flex flex-col items-end max-w-[150px]">
            {sortedControllerIndices.map(i => (
              <div key={i} className="flex items-end space-x-1 flex-row-reverse space-x-reverse w-[120px] justify-end">
                <span className="w-8 text-left">{controllerPositions[i] || `J${i + 1}`}</span>
                <span className="flex space-x-1">
                  {['circle', 'square', 'R2', 'R1', 'triangle'].map(button => (
                    <span key={button} className={rightButtonFlash[i]?.[button] ? "bg-green-400 w-4 h-4 animate-pulse" : "bg-gray-800 w-4 h-4"}></span>
                  ))}
                </span>
              </div>
            ))}
          </div>
          <div className="absolute top-4 flex flex-col items-center w-full">
            {timerOn && (
              <p>{formatTimer(timerSeconds, timerMilliseconds)}</p>
            )}
          </div>
          <div className="absolute bottom-1/4 left-1/2 transform -translate-x-1/2 flex flex-col items-center space-y-2">
            {helpTextOn && (
              <p className="text-lg bg-gray-800 px-4 py-2 rounded min-h-[40px]">主控 Share: 分勝負</p>
            )}
          </div>
          <div className="absolute bottom-10 flex flex-col items-center w-full space-y-2 min-h-[40px]">
            {helpTextOn && (
              <p className="text-sm">主控 L3+R3: 重置, Options: 設定, Touch Pad: 倒數啟動/暫停</p>
            )}
            <p className={controllerConnected.some(c => c) ? "text-green-400" : "text-red-400"}>
              {controllerConnected.some(c => c) ? `手掣已連接: ${sortedControllerIndices.map(i => controllerPositions[i] || `J${i + 1}`).filter(p => p).join(', ')}` : "請連接PS4手制"}
            </p>
          </div>
          {result && (
            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center space-y-4 w-1/3 z-10">
              {result === '平手，請選擇勝方' ? (
                <div className="flex flex-col items-center space-y-2">
                  <p className="text-[2rem] font-bold">平手</p>
                  <p className="text-[2rem] font-bold">請選擇勝方</p>
                </div>
              ) : (
                <p className="text-[8rem] font-bold">{result}</p>
              )}
              {result === '平手，請選擇勝方' ? (
                <div className="flex flex-col items-center space-y-2">
                  <div className="flex space-x-4">
                    <p className="text-lg bg-blue-600 px-3 py-1 rounded">左: 藍</p>
                    <p className="text-lg bg-red-600 px-3 py-1 rounded">右: 紅</p>
                  </div>
                  <p className="text-base">按交叉關閉</p>
                </div>
              ) : (
                <p className="text-base">按交叉關閉</p>
              )}
            </div>
          )}
          {settingsOpen && (
            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center space-y-4 w-1/3 z-10">
              <p className="text-2xl font-bold">設定</p>
              {!isEditingMatchSettings && !isEditingTime && !isEditingManual && !isEditingPosition && !isEditingBasicSettings && !isEditingManualPosition ? (
                <div className="flex flex-col items-center space-y-2 w-full">
                  <p className={selectedOption === 0 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    比賽設置
                  </p>
                  <p className={selectedOption === 1 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    基本設置
                  </p>
                  <p className="text-base">圓圈: 進入, 交叉: 關閉, L1+R1: 解除同步按分限制</p>
                </div>
              ) : isEditingMatchSettings && !isEditingTime && !isEditingManual && !isEditingPosition ? (
                <div className="flex flex-col items-center space-y-2 w-full">
                  <p className={matchSettingsOption === 0 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    計時: {timerOn ? "開" : "關"}
                  </p>
                  {timerOn && (
                    <p className={matchSettingsOption === 1 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                      倒數時間: {formatCountdownTime(countdownTime)}
                    </p>
                  )}
                  <p className={matchSettingsOption === (timerOn ? 2 : 1) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    Gam-jeom: {heartTermination ? "開" : "關"}
                  </p>
                  <p className={matchSettingsOption === (timerOn ? 3 : 2) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    分差模式: {scoreDiff12 === 'off' ? '關' : scoreDiff12 === 'on' ? '12分差' : '黃金得分'}
                  </p>
                  <p className={matchSettingsOption === (timerOn ? 4 : 3) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    比賽模式: {matchMode ? "開" : "關"}
                  </p>
                  {matchMode && (
                    <p className={matchSettingsOption === (timerOn ? 5 : 4) ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                      同時按分: {controllerCount}
                    </p>
                  )}
                  <p className="text-base">左/右: 切換, 圓圈: 手動輸入時間, 交叉: 返回</p>
                </div>
              ) : isEditingManual ? (
                <div className="flex flex-col items-center space-y-2 w-full">
                  <div className="flex space-x-1">
                    <span className={editingDigit === 0 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {Math.floor(tempManualMinutes / 10)}
                    </span>
                    <span className={editingDigit === 1 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {tempManualMinutes % 10}
                    </span>
                    <span>:</span>
                    <span className={editingDigit === 2 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {Math.floor(tempManualSeconds / 10)}
                    </span>
                    <span className={editingDigit === 3 ? "bg-gray-600 px-2 py-1 rounded" : "px-2 py-1"}>
                      {tempManualSeconds % 10}
                    </span>
                  </div>
                  <p className="text-base">左/右: 選擇數字, 上/下: 加減, 圓圈: 確認, 交叉: 返回</p>
                </div>
              ) : isEditingPosition ? (
                <div className="flex flex-col items-center space-y-2 w-full">
                  {Array.from({ length: controllerConnected.filter(c => c).length }, (_, i) => (
                    <div key={i} className="flex space-x-2 items-center w-full">
                      <span className="w-12 text-left">{`J${i + 1}`}</span>
                      <div className="flex space-x-1">
                        {getAvailableOptions(i).map((option, optIndex) => (
                          <span
                            key={optIndex}
                            className={
                              tempControllerPositions[i] === option.value && editingController === i
                                ? "bg-gray-600 px-2 py-1 rounded"
                                : option.isDisabled
                                ? "text-gray-500 px-2 py-1 cursor-not-allowed"
                                : "px-2 py-1"
                            }
                          >
                            {option.value}
                          </span>
                        ))}
                      </div>
                    </div>
                  ))}
                  <p className="text-base">
                    上/下: 選擇手掣, 左/右: 更改位置, 圓圈: {tempControllerPositions.includes('J1') && new Set(tempControllerPositions.filter(p => p !== '未指派')).size === tempControllerPositions.filter(p => p !== '未指派').length ? '確認' : '無效'}, 交叉: 返回
                  </p>
                </div>
              ) : isEditingManualPosition ? (
                <div className="flex flex-col items-center space-y-2 w-full">
                  {Array.from({ length: controllerConnected.filter(c => c).length }, (_, i) => (
                    <div key={i} className="flex space-x-2 items-center w-full">
                      <span className="w-12 text-left">{`J${i + 1}`}</span>
                      <span>{tempManualPositions[i]}</span>
                    </div>
                  ))}
                  <p className="text-base">
                    三角: 依序選擇, 圓圈: {tempManualPositions.includes('J1') && new Set(tempManualPositions.filter(p => p !== '未輸入')).size === tempManualPositions.filter(p => p !== '未輸入').length ? '確認' : '無效'}, 交叉: 返回, 方: 重置
                  </p>
                </div>
              ) : (
                <div className="flex flex-col items-center space-y-2 w-full">
                  <p className={basicSettingsOption === 0 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    震動: {vibrationOn ? "開" : "關"}
                  </p>
                  <p className={basicSettingsOption === 1 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    幫助文字: {helpTextOn ? "開" : "關"}
                  </p>
                  <p className={basicSettingsOption === 2 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    更改手掣位置
                  </p>
                  <p className={basicSettingsOption === 3 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    重設手掣位置
                  </p>
                  <p className={basicSettingsOption === 4 ? "bg-gray-600 px-2 py-1 rounded w-full text-center" : "px-2 py-1 w-full text-center"}>
                    依序設置手掣
                  </p>
                  <p className="text-base">左/右: 切換開關, 圓圈: 進入, 交叉: 返回</p>
                </div>
              )}
            </div>
          )}
          {overtimeOpen && (
            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-gray-800 p-6 rounded-lg shadow-lg flex flex-col items-center space-y-4 w-1/3 z-10">
              <p className="text-2xl font-bold">三角: 分勝負</p>
              <p>加時秒數: {overtimeSeconds}</p>
              <p className="text-base">圓圈: 開始加時, 交叉: 關閉, 左/右: 調整秒數</p>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<ScoreGame />, document.getElementById('root'));
  </script>
</body>
</html>